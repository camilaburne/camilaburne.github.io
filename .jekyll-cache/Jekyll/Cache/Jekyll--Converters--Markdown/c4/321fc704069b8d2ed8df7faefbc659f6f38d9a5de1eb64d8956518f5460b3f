I"¶<p>Hacer queries con SQL es el primer paso de cualquier proyecto de ciencia de datos, y muchas veces, la parte m√°s lenta. Para mejorar el rendimiento de la extracci√≥n de datos, comparto 5 errores para evitar en tu query.</p>

<p><br /></p>

<p>Lo que <em>no</em> hay que hacer:</p>
<ol>
  <li><a href="#t1">SELECT * FROM table</a></li>
  <li><a href="#t2">Cartesian Joins</a></li>
  <li><a href="#t3">Joins en tablas grandes</a></li>
  <li><a href="#t4">DISTINCT</a></li>
  <li><a href="#t5">WITH big tables</a></li>
</ol>

<p><br /></p>

<hr />
<h3 id="lo-que-est√°-mal-con-select--from-table-">Lo que est√° mal con SELECT * FROM table <a name="t1"></a></h3>

<p>Hoy en d√≠a, los datos se guardan en big data warehouses que se organizan en columnas, como Redshift, Hadoop y Big-Query. En este tipo de almacenamiento, es m√°s eficiente acceder a todas las filas desde una columna que acceder a todas las columnas de una sola fila. Por este motivo, hay que evitar usar el * al seleccionar todo, porque se est√° llamando a todas las columnas, usando el m√°ximo de informaci√≥n de una tabla. Para que se corra m√°s r√°pido, conviene nombrar solamente los campos que te interesen.</p>

<p>‚õîÔ∏è <code class="language-plaintext highlighter-rouge">SELECT * FROM table ;</code></p>

<p>‚úÖ <code class="language-plaintext highlighter-rouge">SELECT col1, col2 FROM table ;</code></p>

<p>**Notas sobre almacenamiento en columnas - columnar store - y filas - row store - **:</p>

<p>En el row-store la informaci√≥n se guarda y recupera una fila a la vez, son f√°ciles de leer y escribir, pero no es f√°cil agregar o recuperar todas las filas al mismo tiempo. Este es el caso m√°s tradicional, que se suele ver en tutoriales, de una ‚Äúbase de datos de estudiantes‚Äù en la que es de inter√©s ver los datos de un individuo en particular. Anteriormente se usaba este tipo de almacenamiento, pero fue quedando desactualizado desde que la informaci√≥n se guarda masivamente, ocupando millones de filas.</p>

<p>Para este caso se usa el columnar-store, almacenamiento de datos en columnas, que es com√∫n para informaci√≥n OLAP (online analytical processing). En este caso nos interesa realizar c√°lculos sobre campos, por ejemplo, obtener un n√∫mero total de transacciones y  calcular su monto promedio.</p>

<p>En ambas situaciones, las tabla se ve exactamente iguales, pero el rendimiento es diferente seg√∫n los tipos de consulta que ejecutamos. Para el almacenamiento orientado a filas, podr√≠amos ver f√°cilmente toda la informaci√≥n de una unidad determinada, y en el almacenamiento orientado a columnas, podemos procesar agregados en columnas muy r√°pido. Como en aplicaciones de big data nos interesa realizar c√°lculos en columnas, hoy en d√≠a las bases de datos m√°s comunes siguen este estilo. <a href="https://medium.com/bluecore-engineering/deciding-between-row-and-columnar-stores-why-we-chose-both-3a675dab4087#:~:text=In%20row%20oriented%20databases%2C%20these,data%20is%20read%20at%20once.">M√°s sobre row y columnar stores.</a></p>

<p><br /></p>

<h3 id="errores-en-joins-cartesianos-">Errores en Joins Cartesianos <a name="t2"></a></h3>

<p>Los joins cartersians, aka cross joins, devuelven todas las combinaciones posibles de los registros de dos tablas, por lo que si cruz√°s dos tablas con N filas, los resultados van a tener NxN filas. A menos que est√©s dise√±ando un experimento o creando una vista, en la vida real nunca vas a user esta combinaci√≥n.</p>

<p>En algunos editores de SQL, este es el join predeterminado cuando no especific√°s el nombre, por lo que siempre, siempre, siempre, hay que escribir: <code class="language-plaintext highlighter-rouge">INNER JOIN</code> o<code class="language-plaintext highlighter-rouge"> LEFT JOIN</code>. No es necesario ning√∫n otro, ni siquiera <code class="language-plaintext highlighter-rouge">RIGHT JOIN</code> porque eso es para gente rara.</p>

<p>‚õîÔ∏è</p>
<pre>
SELECT
 t1.col1,
 t2.col2
FROM table1 as t1, table2 as t2 ;
</pre>

<p>‚úÖ</p>
<pre>
SELECT
 t1.col1,
 t2.col2
 FROM table1 as t1
 LEFT JOIN table2 as t2 ON t1.id = t2.t1_id ;
</pre>

<p><br /></p>

<h3 id="evitar-joins-con-tablas-enormes-">Evitar joins con tablas enormes <a name="t3"></a></h3>

<p>Hablando de joins: no juntes tablas enormes entre s√≠. Es mejor hacer un proceso de dos pasos: primero reduc√≠ cada tabla original a trav√©s de una subquery, luego un√≠ estas dos subqueries.
Aunque parece m√°s complejo tener consultas anidadas, te va a ahorrar tiempo, ya que se reduce significativamente el tiempo de ejecuci√≥n.</p>

<p>‚õîÔ∏è</p>
<pre>SELECT
  c.id,
  c.age,
  t.amt

FROM customers c                          
LEFT JOIN transactions t on c.id = t.cust_id
</pre>

<p>‚úÖ</p>
<pre>SELECT *    

FROM (
      SELECT id, age
      FROM customers
      ) c        
LEFT JOIN (
      SELECT cust_id, amt
      FROM transactions) t on c.id = t.cust_id
</pre>

<h3 id="distinct">DISTINCT<a name="t4"></a></h3>

<p>La sentencia DISTINCT es esencialmente un grupo by, pero es m√°s costoso porque uno se olvida cu√°nto se est√° agrupando. En general se usa para obtener registros √∫nicos, generalmente cuando hay duplicados en tu tabla original o en cualquiera de las tablas que juntaste a trav√©s de un join. <code class="language-plaintext highlighter-rouge">DISTINCT</code> funciona ordenando primero todos los datos y luego agrupando por todos los campos incluidos en la instrucci√≥n SELECT. Es decir, es un group by de <em>todo</em>, por eso es lento.</p>

<p>Usar <code class="language-plaintext highlighter-rouge">DISTINCT</code> en varias columnas que no son √≠ndices, es costoso en tiempo y memoria, as√≠ que conviene evitarlo. En su lugar, se pueden usar tablas temporales con pre-agregados, y evitar uniones con tablas en crudo.</p>

<p><br /></p>

<h3 id="with-">WITH <a name="t5"></a></h3>
<p>WITH se usa para nombrar una subquery, para que puedas usarla en tu consulta principal. Esto podr√≠a ser √∫til para estructurar su c√≥digo, cuando est√°s anidando consultas, pero puede ser costoso ya que est√°s ejecutando todas sus sub-queries a la vez.</p>

<p>Consultar muchas tablas grandes y llenas al mismo tiempo es una mala idea. A veces, cuando tengo que crear vistas o tablas que involucran muchas combinaciones, como m√°s de 10, es mejor crear tablas temporales intermedias, e ir gener√°ndolas de una a la vez.</p>

<p>Por ejemplo, imaginemos que tenemos una tabla de clientes, una tabla de transacciones y una tabla de ciudad. Queremos tener el importe medio de la compra m√°xima que realiza un cliente en cada ciudad.</p>

<p>En lugar de ejecutar dos consultas al mismo tiempo:</p>

<p>‚õîÔ∏è</p>
<pre>
WITH my_big_table
  as (SELECT
      c.id,
      c.age,
      a.city,  
      max(t.amt) as max_amt      
      FROM customers c                          
      LEFT JOIN transactions t on c.id = t.cust_id
      LEFT JOIN cust_address a on c.id = a.cust_id
      group by 1,2,3
      )  

  SELECT a.city, avg(t.amt)
  group by 1 ;

</pre>

<p>Es mejor crear una tabla temporal y hacerlo en dos pasos:</p>

<p>‚úÖ</p>
<pre>
CREATE TEMPORARY TABLE AS max_amt_cust
  ( SELECT
      c.id,
      max(t.amt) as max_amt      
      FROM customers c                          
      LEFT JOIN transactions t on c.id = t.cust_id
      GROUP BY 1
  );

SELECT
  a.city(),
  max(m.amt) as max_amt      
FROM cust_address a
LEFT JOIN max_amt_cust m on m.id = a.cust_id
GROUP BY 1

</pre>

<p>Recib√≠ estos consejos de mi gerente despu√©s de que identificara consultas que tardaban minutos en ejecutarse. Como regla general, si una consulta tarda m√°s de 30 segundos, es probable que se haya alguno de estos cinco errores en tu SQL y que puedas solucionarlo limitando el n√∫mero de columnas, corrigiendo joins, haciendo tablas intermedias y group by a mano; evitando distinct, with y select *.</p>
:ET